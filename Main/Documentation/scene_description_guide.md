# Scene Description Guide {#main_scene_description_guide}

[TOC]

Here, you will learn about the scene description language used in Photon, sometimes referred to as PSDL (Photon Scene Description Language). It is a special format created for storing scene data as well as controlling the behavior of the render engine. We also have [API generators](https://github.com/TzuChieh/Photon-v2/tree/master/SDLGenerator/SDLGen) for different programming languages, allowing users to programmatically build scene descriptions and output customized formats for various applications. The reference for all engine features exposed as PSDL can be found [here](@ref main_scene_description_reference).

## Introduction

Let us first see how a simple scene would be represented in PSDL. The hello-world scene that will be rendered by Photon looks like this

![PSDL Hello World](SDL/sdl_hello_world_scene.jpg "Rendered hello-world scene."){html: width=60%}

This image can be generated by feeding the following descriptions into Photon:

```csharp
observer(single-lens) @observer = [real fov-degrees 30] [vector3 pos "0 6 40"] [vector3 dir "0 0 -1"] [vector3 up-axis "0 1 0"];
sample-source(stratified) @sampler = [integer samples 10];
visualizer(path-tracing) @visualizer = [enum sample-filter gaussian][enum estimator bneept];

option(single-frame-render-session) @session = [vector2 frame-size "512 512"] [string visualizer @visualizer] [string observer @observer] [string sample-source @sampler];

geometry(rectangle) @plane = [real width 15] [real height 15];
geometry(sphere) @ball = [real radius 2.5];
image(constant) @white = [real-array values 0.9];
material(matte-opaque) @diffuse = [image albedo @white];

actor(model) @ground = [geometry geometry @plane] [material material @diffuse];
actor(model).rotate(@ground) = [vector3 axis "1 0 0"] [real degrees -90];
actor(model).scale(@ground) = [vector3 amount "10 10 10"];

actor(model) @object = [geometry geometry @ball] [material material @diffuse];
actor(model).translate(@object) = [vector3 amount "0 2.5 0"];

actor(rectangle-light) @topLight = [spectrum color "1 1 0.8"] [real watts 400] [real width 2] [real height 2];
actor(light).translate(@topLight) = [vector3 amount "0 10 0"];
actor(light).rotate(@topLight) = [vector3 axis "1 0 0"] [real degrees 90];
```

> [!note]
> More example scenes can be found in the [./scenes/](https://github.com/TzuChieh/Photon-v2/tree/master/scenes) folder in the [GitHub repository](https://github.com/TzuChieh/Photon-v2).

Scene descriptions can be stored in a text file (.p2 filename extension) and [loaded by Photon for rendering](@ref photon_cli_readme). Without getting into too much details, the scene description shown above can be summarized as:

* Declaring a [render session](@ref ph::RenderSession):
  - An "observer" to view the scene
  - A "sampler" to provide randomness for numerical integration
  - A "visualizer" to *draw* the scene from the observer's point of view
* Declaring data:
  - A 15 m x 15 m plane
  - A ball with 2.5 m radius
  - A white material
* Placing objects in the scene:
  - We can create a "ground" object by combining the plane and white material. Photon's default coordinate system is right-handed, y-up, x-right. Since a `rectangle` geometry faces +z by default, a series of transformations are required to place the ground object with the desired rotation and scale.
  - Place a spherical object on the ground
  - Finally, a 400 W rectangular light is placed above the spherical object

After saving the scene description as `hello_world.p2` under the build/install directory, you can run the following command in the same directory to render the scene as described:

```shell
./bin/PhotonCLI -s ./hello_world.p2 -t 8
```

> [!note]
> Most components of Photon expect the build/install directory to be their working directory, not the directory that contains the executable.

## Language Basics

PSDL is a command-like system and the commands can be roughly categorized into two parts: **header** and **clause**. Commands are normally structured in the following way:

`type-category`(`type-name`) \@`name` = `clauses`;

where `=` is the token that separates the header and clauses, which can be naturally interpreted as assigning the RHS clauses into the LHS resource denoted by `name`. For example, to create a unit-sized rectangle, we write:

```csharp
geometry(rectangle) @plane = [real width 1] [real height 1];
```

`geometry(rectangle)` is the full type information for a [geometry](@ref ph::Geometry) resource. By specifying the type name `rectangle` in the parantheses after `geometry`, we are creating a [rectangle](@ref ph::GRectangle) geometry named `plane`. Its dimension properties are specified via the two square-bracket enclosed clauses that follow the assignment token. In most cases, a clause contains three space-separated parts: a type, a name and a value. A clause is the most fundamental data block in PSDL, and multiple clauses form a [SDL data packet](@ref ph::SdlDataPacketInterface). In the example of creating a unit-sized rectangle, `[real width 1] [real height 1]` is the data packet for initializing the geometry resource named `plane`. Now, the intention of the following line should be quite obvious:

```csharp
geometry(sphere) @ball = [real radius 2.5];
```

It creates a geometry resource named `ball`, which is a [sphere](@ref ph::GSphere) with `radius = 2.5`. We will dive further into the topics of type and clause later.

As you may have noticed, all commands end with a trailing semi-colon. To disable a command or write a comment, simply put two slashes before the line:

```csharp
// These commands are being disabled
//sample-source(stratified) @sampler = [integer samples 10];
//actor(model).scale(@ground) = [vector3 amount "10 10 10"];
```

> [!note]
> As long as you do not break any keyword or symbol of PSDL, a single command can be dissected into multiple lines. Cramming multiple commands into a single line is also supported.

In the next sections, we will formally introduce the syntactic structures of PSDL commands.

## Type Category

`type-category`(type-name) \@name = clauses;

Describes the category to which the current command belongs. For example, the command that creates a geometry states that its category is `geometry` in its type category section. There are many categories in PSDL. In addition to the ones seen in the above hello-world scene description, we also have `image`, `object` and much more.

## Type Name

type-category(`type-name`) \@name = clauses;

Type names generally *add details* to the type category. Again, in the command that creates a geometry, we know that we are now creating a `rectangle` geometry from the command fragment `geometry(rectangle)`. Type category and type name are often combined and are called **full type name** together. Full type name is only needed if the underlying engine operation requires it (such as creating a resource). For executor calls (see the later section), type name can be omitted (will be automatically deduced from the referenced resource) sometimes.

## Data Name

type-category(type-name) \@`name` = clauses;

The data name is the name given to the command (e.g., as a resource name, or a reference name) and is always prefixed by `@`. Note that `@` is part of the syntax rather than part of the name. Also, names with whitespace characters should be enclosed by double quotes, see the following example to understand more clearly:

```csharp
// @ is part of the syntax and should be left out of the double quotes. In this
// example, we created a sphere named "ball name with spaces".
geometry(sphere) @"ball name with spaces" = [real radius 2.5];
actor(model) @balloon = [geometry geometry @"ball name with spaces"];
```

## Clauses

type-category(type-name) \@name = `clauses`;

Clause is a structure that stores parameters for a command. It has the following form:

[`type-category` `parameter-name`:`tag` `values`]

It is worth pointing out that the `parameter-name` does not need to start with `@`. The `values` section can have many forms such as numerical values (as seen earlier), arrays, and even stand-alone data files (we call them **PSDL Resource Identifier**). Details of this section will be introduced in [later part](@ref psdl_resource_identifier) of the guide.

[//TODO]: <> (reference & struct types)

```csharp
// By writing these, we now added a plane, a ball and a material to the scene!
// At this stage, they are like props and are not visible. They still need
// actors to show up in the rendered scene.
geometry(rectangle)    @plane   = [real width 15] [real height 15];
geometry(sphere)       @ball    = [real radius 2.5];
image(constant)        @white   = [real-array values 0.9];
material(matte-opaque) @diffuse = [image albedo @white];
```

With PSDL, you can create almost all kinds of objects the rendering system has to offer. In later sections, we will see that it is also possible to perform [operations](@ref operations) on these objects via PSDL.

## Operations {#operations}

[//TODO]: <> (introduce PSDL executors)

> [!tip]
> Go back and check the hello-world scene description again. You should be able to understand most of the lines now.

## PSDL Resource Identifier {#psdl_resource_identifier}

[//TODO]: <> (include, PRI, scene working directory)

## Appendix

[Full documentation of PSDL commands](@ref main_scene_description_reference).

